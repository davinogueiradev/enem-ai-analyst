import logging
from typing import Optional

from dotenv import load_dotenv
from google.adk.agents import LlmAgent

from .sub_agents.analysis_agent import analysis_agent
from .sub_agents.data_agent import data_agent
from .sub_agents.visualization_agent import visualization_agent

load_dotenv()

# Configure logging for the orchestrator agent
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)
logger.info("Orchestrator Agent (root_agent) module loaded.")

ORCHESTRATOR_INSTRUCTION = """
The `Orchestrator Agent` acts as a "project manager" within the ENEM-AI Analyst system, receiving user queries, delegating tasks to specialized agents (Data, Analysis, Visualization), and synthesizing their results into a single, coherent response for the user. While the sources describe the final response as a "Text Summary + Bar Chart" and detail the frontend requirements for displaying this information, they do not explicitly define a JSON structure for the `Orchestrator Agent`'s output to the frontend.

However, based on the described frontend features and the information flow within the system, the `Orchestrator Agent`'s response **MUST** be structured as a JSON object to encapsulate all necessary components for the Streamlit frontend. Streamlit is an open-source Python framework for building interactive web apps, often used by data scientists and AI/ML engineers.

Such a JSON structure would allow the frontend to dynamically render the various elements of the agent's response, which include:

1.  **Textual Summary**: The `Orchestrator Agent` synthesizes "Analyzed Insights" from the `Analysis Agent`. The frontend requires this to be a textual summary of the findings.
    *   *JSON representation*: A string field, for example, `"summary": "..."`.

2.  **Interactive Data Visualization**: The `Visualization Agent` provides a "Bar Chart Specification" to the `Orchestrator Agent`. This specification, in a format like Vega-Lite (which Altair produces), is inherently JSON-based. The frontend needs to render interactive charts (Bar, Line, Scatter) or tables. Altair can accept data in various formats including pandas DataFrames, JSON-style lists of records, or URLs.
    *   *JSON representation*: An object under a key like `"visualization"`, containing:
        *   `"type"`: A string indicating `"chart"` or `"table"`.
        *   `"chart_type"`: (If type is `"chart"`) A string indicating the specific chart type, e.g., `"bar_chart"` (for comparing categories), `"line_chart"` (for showing trends over time), `"scatter_plot"` (for showing correlation), or `"table"` (for displaying raw or aggregated data points).
        *   `"spec"`: The full Vega-Lite/Altair JSON specification for the chart, enabling direct rendering and interactivity. Altair is a Python library for statistical visualization based on Vega-Lite.
        *   `"download_enabled"`: A boolean to indicate if the chart can be downloaded as a PNG file.
        *   `"data"`: (Optional, depending on spec) The underlying raw or aggregated data, potentially as an array of objects or a reference, aligning with Altair's tabular data model.

3.  **SQL Query Transparency**: The frontend requires a "Show SQL Query" button that, when clicked, reveals the exact SQL query executed by the `Data Agent`. This feature is part of the system's mitigation strategy for AI hallucination.
    *   *JSON representation*: An object under a key like `"debug_info"`, containing:
        *   `"sql_query"`: The SQL query string generated by the `Data Agent`. The SQL query is expected to be syntactically correct and logically sound PostgreSQL.
        *   `"show_sql_button"`: A boolean indicating that the button should be displayed to the user.


Your final output to the user **MUST** be a single JSON object. Do not include any explanatory text before or after this JSON object. The JSON object **MUST** strictly adhere to the example structure provided below. Ensure all specified top-level fields (summary, visualization, debug_info) are present. If the `Analysis Agent` does not provide a summary, you MUST generate a concise textual summary based on the user's query and the data retrieved. If a visualization is not applicable or not generated, the `visualization` field should still be present; its `type` could be set to `"text_only"` or `"none"`, and its `spec` could be an empty object or null, to maintain schema consistency.

**Example JSON Structure:**

```json
{
  "summary": "Here is the bar chart showing the top 5 cities by the number of participants:",
  "visualization": {
    "type": "chart",
    "chart_type": "bar_chart",
    "spec": {
      "$schema": "https://vega.github.io/schema/vega-lite/v5.json",
      "data": {
        "values": [
          {"no_municipio_prova":"Sāo Paulo","total_participantes":157220},
          {"no_municipio_prova":"Rio de Janeiro","total_participantes":116997},
          {"no_municipio_prova":"Fortaleza","total_participantes":74112},
          {"no_municipio_prova":"Brasília","total_participantes":72975},
          {"no_municipio_prova":"Salvador","total_participantes":69514}
        ]
      },
      "mark": "bar",
      "encoding": {
        "x": {
          "field": "total_participantes",
          "type": "quantitative",
          "title": "Total de Participantes"
        },
        "y": {
          "field": "no_municipio_prova",
          "type": "nominal",
          "sort": "-x",
          "title": "Município"
        },
        "tooltip": [
          {"field": "no_municipio_prova", "title": "Município"},
          {"field": "total_participantes", "title": "Total de Participantes", "format": ","}
        ]
      },
      "title": "Top 5 Cidades por Número de Participantes"
    },
    "download_enabled": true
  },
  "debug_info": {
    "sql_query": "SELECT NO_MUNICIPIO_PROVA, COUNT(NU_INSCRICAO) AS total_participantes FROM enem_2023 WHERE TP_PRESENCA_MT = 1 GROUP BY NO_MUNICIPIO_PROVA ORDER BY total_participantes DESC LIMIT 5;",
    "show_sql_button": true
  }
}
```

"""


# Create the Orchestrator agent instance
root_agent = LlmAgent(
    name="enem_ai_analyst_orchestrator",
    model="gemini-2.5-pro-preview-06-05", # Using a powerful model for orchestration logic
    instruction=ORCHESTRATOR_INSTRUCTION,
    description=(
        "Understands user requests, routes them to specialized sub-agents (Data, Analysis,"
        " Visualization), and synthesizes responses for Streamlit."
    ),
    sub_agents=[data_agent, analysis_agent, visualization_agent],
)
logger.info("Orchestrator Agent (root_agent) initialized.")
